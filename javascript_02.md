# Javascript基础教程<sup>shine</sup>

## 第六章面向对象的程序设计

ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”

### 6.1理解对象

创建自定义对象的最简单方式就是创建一个Object的实例，然后再为它添加属性和方法。

#### 6.1.1 属性类型

ECMA262第5版在定义只有内部采用的特性（attribute）时，描述了属性（property）的各种特征。
ECMAScript中有两种属性：数据属性和访问器属性。

#### 1.数据属性

数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有两个描述其行为的特性。
- （1）[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，是否修改属性的特性，或者能否把属性修改为访问器属性。
- （2）[[Enumerable]]:表示能否通过for-in循环返回属性。
- （3）[[Writable]]:表示能否修改属性的值。
- （4）[[Value]]:包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为undefined。

要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable和value。设置其中的一个或多个值，可以修改对应的特性值。

#### 2.访问器属性

访问器属性不包含数据值；它们包含一对儿getter和setter函数（不过，这两个都不是必需的）。
- （1）[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。
- （2）[[Enumerable]]:表示能否通过for-in循环返回属性。
- （3）[[Get]]:在读取属性时调用的函数。默认值为undefined。
- （4）[[Set]]:在写入属性时调用的函数。默认值为undefined。
访问器属性不能直接定义，必须使用Object.defineProperty()来定义。

#### 6.1.2 定义多个属性

由于为对象定义多个属性的可能性很大，ECMAScript5又定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。

#### 6.1.3 读取属性的特性

使用ECMAScript5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性configurable、enumerable、get和set；如果是数据属性，这个对象的属性有configuragble、enumerable、writable和value。

### 6.2 创建对象
#### 6.2.1工厂模式
#### 6.2.2 构造函数模式

按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。

对象的constructor属性最初是用来标识对象类型的。但是，提到检测对象类型，还是instanceof操作符要更可靠一些。
创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。

1.将构造函数当作函数

构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过new操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过new操作符来调用，那它跟普通函数也不会有什么两样。

2.构造函数的问题

使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。

#### 6.2.3 原型模式

我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。

- 1.理解原型对象

无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。

虽然在所有实现中都无法访问到[[Prototype]]，但可以通过isPrototypeOf()方法来确定对象间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用isPrototypeOf()方法的对象，那么这个方法就返回true。

ECMAScript5新增加了一个新方法，叫Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值。

当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。使用delete操作符则可完全删除实例属性，从而让我们能够重新访问原型中的属性。

使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。只在给定属性存在于对象实例中时，才会返回true;

- 2.原型与in操作符

有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在通过对象能够访问给定属性时返回true,无论该属性存在于实例中还是原型中。

- 3.更简单的原型语法

用一个包含所有属性和方法的对象字面量来重新整个对象。

- 4.原型的动态性

由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例中反映出来——即使是先创建了实例后修改原型也是如此。

- 5.原生对象的原型

原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。

- 6.原型对象的问题

原型模式最大的问题是由其共享的本性所导致的。

#### 6.2.4 组合使用构造函数模式和原型模式

构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。

#### 6.2.5 动态原型模式

动态原型模式把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。

#### 6.2.6 寄生构造函数模式

寄生构造函数模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。

#### 6.2.7 稳妥构造函数模式

所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者防止数据被其他应用程序（如Mashup程序）改动时使用。

稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一时新创建对象的实例方法不引用this；二是不使用new操作符调用构造函数。

### 6.3 继承

许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。

#### 6.3.1 原型链

ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。

给原型添加方法的代码一定要放在替换原型的语句之后。

在通过原型链来实现继承时，不能使用字面量创建原型方法。因为这样做就会重写原型链。

原型链实现继承最主要的问题来自包含引用类型值的原型。第二个问题是在创建子类型的实例时，不能向超类型的构造函数传递参数。

#### 6.3.2 借用构造函数

借用构造函数（constructor straling）技术（有时候也叫做伪造对象或经典继承）。其基本思想即：在子类型构造函数的内部调用超类型构造函数。

在子类中使用call()或apply()调用父类构造函数。

借用构造函数的问题：仅仅借用构造函数，那么方法都在构造函数中定义，因此函数复用就无从谈起了。

#### 6.3.3 组合继承

组合继承（combination inheritance）,有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。

其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。

#### 6.3.4 原型式继承

借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。

ECMAScript5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。

#### 6.3.5 寄生式继承

寄生式继承：创建一个仅用于封装过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。

#### 6.3.6 寄生组合式继承

所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。

```javascript
       function inheritPrototype(subType,superType){
              var prototype = object(superType.prototype);
              prototype.constructor = subType;
              subType.prototype = prototype;
       }
```
6.4 小结

JavaScript主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型来实现的。

## 第七章函数表达式

定义函数的方式有两种：一种是函数声明，另一种就是函数表达式。
关于函数声明，它的一个重要特征就是函数声明提升（function declaration hoisting），意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。
第二种创建函数的方式是使用函数表达式。函数表达式有几种不同的语法形式。下面是最常见的一种形式。
```javascript
    var functionName = function(arg0,arg1,arg2)
    {
           //函数体
    }
```
这种形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量functionName。这种情况下创建的函数叫做匿名函数（anonymous function），因为function关键字后面没有标识符。（匿名函数有时候也叫拉姆达函数。）匿名函数的name属性是空字符串。

### 7.1递归

arguments.callee是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用。
```javascript
       function factorial(num)
       {
              if(num <= 1) {
                     return 1;
              }else{
                     returnnum*arguments.callee(num-1);
              }
       }
```

### 7.2 闭包

闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。

当某个函数第一次被调用时，会创建一个执行环境（execution context）及相应的作用域链，并把作用域链赋值给一个特殊的内部属性（即\[\[Scope\]\]）。然后，使用this、arguments和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。

后台的每个执行环境都有一个表示变量的对象——变量对象。
作用链本质上是一个执行变量对象的指针列表，它只引用但不实际包含变量对象。
在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中。

#### 7.2.1 闭包与变量

作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。

#### 7.2.2 关于this对象

this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。不过匿名函数的执行环境具有全局性，因此其this对象通常指向window（通过call()或apply()改变函数执行环境的情况下，this就会指向其他对象。）

#### 7.2.3 内存泄漏

内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。

### 7.3 模仿块级作用域

JavaScript从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化）。匿名函数可以用来模仿块级作用域并避免这个问题。

用作块级作用域（通常称为私有作用域）的匿名函数的语法如下所示：
```javascript
       （function(){
              //这里是块级作用域
       }）
```
以上代码定义并立即调用了一个匿名函数。将函数声明包含着一对圆括号中，表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。

在匿名函数中定义的任何变量，都会在执行结束时被销毁。
这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。

### 7.4 私有变量

严格来讲，JavaScript中没有私有成员的概念；所有的对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能再函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。

有权访问私有变量和私有函数的公有方法称为特权方法（privileged  method）。

#### 7.4.1 静态私有变量

通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法。

#### 7.4.2 模块模式

模块模式（module pattern）则是为单例创建私有变量和特权方法。所谓单例（singleton），指的就是只有一个实例的对象。按照惯例，JavaScript是以字面量的方式来创建单例对象的。

如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。

#### 7.4.3 增强的模块模式

有人进一步改进了模块模式，即在返回对象之前加入对其增强的代码。这种增强的模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况。

### 7.5小结

函数表达式的特点：

- （1）函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫做匿名函数。
- （2）在无法确定如何引用函数的情况下，递归函数就会变得比较复杂。
- （3）递归函数应该始终使用arguments.callee来递归调用本身，不要使用函数名——函数名可能会发生变化。

当函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下：

- （1）在后头执行环境中，闭包的作用链包含着它自己的作用域、包含函数的作用域和全局作用域。
- （2）通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。
- （3）但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存在保存到闭包不存在为止。

## 第八章 BOM

BOM（浏览器对象模型）提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。

### 8.1 window对象

BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。这意味着网页中定义的任何一个对象、变量和函数，都以window作为其Global对象，因此有权访问parseInt()等方法。

#### 8.1.1 全局作用域

抛开全局变量会成为window对象的属性不谈，定义全局变量与在window对象上直接定义属性还是有一点差别：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。
尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以直达某个可能未声明的变量是否存在。

#### 8.1.2 窗口关系及框架

如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。在frames集合中，可以通过数值索引（从0开始，从左至右，从上到下）或者用框架名称来访问相应的window对象。每个window都有一个name属性，其中包含框架名称。

top对象始终指向最高（最外）层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确地访问另一个框架。因为对于一个在框架中编写的任何代码来说，其中的window对象指向的都是那个框架的特定实例，而非最高层框架。

与top相对的另一个window对象是parent。parent（父）对象始终指向当前框架的直接上层框架。在某些情况下，parent有可能等于top；但在没有框架的情况下，parent一定等于top（此时它们都等于window）。

注意，除非最高层窗口时通过window.open()打开的，否则其window对象的name属性不会包含任何值。

与框架有关的最后一个对象是self，它始终指向window；实际上，self和window对象可以互换使用。引入self对象的目的只是为了与top和parent对象对应起来，因此它不格外包含其他值。

#### 8.1.3 窗口位置

使用下列代码可以跨浏览器取得窗口左边和上边的位置。
```javascript
       var leftPos = (typeofwindow.screenLeft == "number") ? window.screenLeft : window.screenX;
       var topPos = (typeofwindow.screenTop == "number") ? window.screenTop : window.screenY;
```
使用moveTo()和moveBy()方法倒是有可能将窗口精确地移动到一个新位置。这两个方法都接收两个参数，其中moveTo()接收的是新位置的x和y坐标值，而moveBy()接收的是在水平和垂直方向上移动的像素数。

#### 8.1.4 窗口大小
```javascript
function getInfo(){
       var s = "";
       s += " 网页可见区域宽：" + document.body.clientWidth;
       s += " 网页可见区域高：" + document.body.clientHeight;
       s += " 网页可见区域宽：" + document.body.offsetWidth + " (包括边线和滚动条的宽)";
       s += " 网页可见区域高：" + document.body.offsetHeight + " (包括边线的宽)";
       s += " 网页正文全文宽：" + document.body.scrollWidth;
       s += " 网页正文全文高：" + document.body.scrollHeight;
       s += " 网页被卷去的高(ff)：" + document.body.scrollTop;
       s += " 网页被卷去的高(ie)：" + document.documentElement.scrollTop;
       s += " 网页被卷去的左：" + document.body.scrollLeft;
       s += " 网页正文部分上：" + window.screenTop;
       s += " 网页正文部分左：" + window.screenLeft;
       s += " 屏幕分辨率的高：" + window.screen.height;
       s += " 屏幕分辨率的宽：" + window.screen.width;
       s += " 屏幕可用工作区高度：" + window.screen.availHeight;
       s += " 屏幕可用工作区宽度：" + window.screen.availWidth;
       s += " 你的屏幕设置是 " + window.screen.colorDepth + " 位彩色";
       s += " 你的屏幕设置 " + window.screen.deviceXDPI + " 像素/英寸";
       alert (s);
}
```
#### 8.1.5 导航和打开窗口

使用window.open方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。这个方法可以接收4个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。

#### 8.1.6 间歇调用和超时调用

JavaScript是单线程语言，但它允许通过设置超时值和间歇时间来调度代码在特定的时刻执行。前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。

调用setTimeout()之后，该方法会返回一个数值ID，表示超时调用。这个超时调用ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。

超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined。

一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。

#### 8.1.7 系统对话框

浏览器通过alert()、confirm()和prompt()方法可以调用系统对话框向用户显示消息。
```javascript
       //显示“打印”对话框
       window.print();

       //显示“查找”对话框
       window.find();
```
### 8.2 location对象

location是最有用的BOM对象之一，它提供了当前窗口中加载文档有关的信息，还提供了一些导航功能。

#### 8.2.1 查询字符串参数

#### 8.2.2 位置操作

使用location对象可以通过很多方式来改变浏览器的位置。最常见的方式就是使用assign()方法并为其传递一个URL。如果是将location.href或window.location设置为一个URL值，也会调用assign()方法。

replace()只接受一个参数，即要导航到的URL；结果虽然会导致浏览器位置改变，但不会在历史记录中生成新记录。在调用replace()方法之后，用户不能回到前一个页面。
```javascript
       location.reload();//重新加载（有可能从缓存中加载）
       location.reload(true);//重新加载（从服务器重新加载）
```

### 8.3 navigator对象

#### 8.3.1 检测插件

检测浏览器中是否按照了特定的插件是一种最常见的检测例程。对于非IE浏览器，可以使用plugins数组来达到这个目的。该数组中的每一项都包含下列属性。

- （1）name：插件的名字。
- （2）description：插件的文件名。
- （3）filename：插件的文件名。
- （4）length：插件所处理的MIME类型数量。

plugins集合有一个名叫refresh()的方法，用于刷新plugins以反映最新安装的插件。这个方法接收一个参数：表示是否应该重新加载页面的一个布尔值。如果将这个值设置为true，则会重新加载包含插件的所有页面；否则，只更新plugins集合，不重新加载页面。

#### 8.3.2 注册处理程序

Firefox2为navigator对象新增了registerContentHandler()和registerProtocolHandler()方法（这两个方法是在HTML5中定义的）。这两个方法可以让一个站点指明它可以处理特定类型的信息。
其中，registerContentHandler()方法接收三个参数：要处理的MIME类型、可以处理该MIME类型的页面的URL以及应用程序的名称。
registerProtocolHandler()方法，它也接收三个参数：要处理的协议、处理该协议的页面的URL和应用程序的名称。

### 8.4  screen对象

screen对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器信息，如像素宽度和高度等。

### 8.5 history对象

history对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。

使用go()方法可以在用户的历史记录中任意跳转，可以向后也可以向前。这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。负数表示向后跳转，正数表示向前跳转。
也可以给go()方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置。
还可以使用两个简写的方法back()和forward()来代替go()。
history对象还有一个length属性，保存这历史记录的数量。

[返回上一篇](javascript_01.md)
[继续下一篇](javascript_03.md)