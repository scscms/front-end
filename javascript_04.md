# Javascript基础教程<sup>shine</sup>

## 前三章Javascript的核心概念

Javascript的核心语言特性在ECMA-262中是以名为ECMAScript的伪语言的形式来定义的。

- （1）ECMAScript中的基本数据类型包括Undefined、Null、Boolean、Number和String。ES6新添symbol。
- （2）与其他语言不同，ECMAscript没有为整数和浮点数值分别定义不同的数据类型，Number类型可以用于表达所有数值。
- （3）ECMAScript中也有一种复杂的数据类型，即Object类型，该类型是这门语言中所有对象的基础类型。
- （4）严格模式为这门语言中容易出错的地方施加了限制。(“use strict”)
- （5）ECMAScript提供了很多与C及其他类C语言中相同的基本操作符，包括算数操作符、布尔操作符、关系操作符、相等操作符及赋值操作符等。
- （6）ECMAScript从其他语言中借鉴了很多流控制语句，如if语句、for语句和switch语句等。

ECMAScript中的函数与其他语言中的函数有诸多不同之处。

* （1）无须指定函数的返回值，因为任何ECMAScript都可以在任何时候返回任何值。
* （2）实际上，未指定返回值的函数返回的是一个特殊的undefined值。
* （3）ECMAScript中也没有函数签名的概念，因为其参数是以一个包含零或多个值的数组形式传递的(arguments不是真正的数组)。
* （4）可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数。ES6引入rest参数，形式为"...变量名"，它是真正的数组。
* （5）由于不存在函数签名的特性，ECMAScript函数不能重载。

## 第四章　变量作用域和内存问题

javascript变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。

### 4.1 基本类型和应用类型的值

与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。

ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型的值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样(这点我并不认同，引用类型传入函数仍是引用路径，函数内修改变量对象将直接修改该对象)。

typeof操作符是确定一个变量是字符串、数值、布尔值，还是undefined的最佳工具。

ECMAScript提供了instanceof操作符，其语法如下：
```Javascript
var result = variable instanceof constructor;
```
如果变量是给定的引用类型（根据它的原型链来识别）的实例，那么instanceof操作符就会返回true。

### 4.2 执行环境及作用域

执行环境（execution context，为简单起见，有时候也称为“环境”）是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权交给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制控制着。

#### 4.2.1 延长作用域链

虽然执行环境的类型总共只有两种——全局和局部（函数），但还是有其他办法来延长作用域链。这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发送这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：

- （1）try-catch语句的catch块。
- （2）with语句。

这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。

#### 4.2.2 没有块级作用域

JavaScript没有块级作用域经常会导致理解上的困惑。

#### 1.声明变量

使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。

ES6新增了let和const命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。const声明一个只读的常量。一旦声明，常量的值就不能改变。如果声明的是对象，引用地址不能变，但对象属性可变化。
var与let,const区别于几点：变量提升，暂时性死区，重复声明，块级作用域。

#### 2.查询标识符

当某个环境中为了读取或写入而引用了一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。

### 4.3 垃圾收集

JavaScript具有自动垃圾回收基址，也就是说，执行环境会负责管理代码执行过程中使用的内存。

### 4.4 小结

JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下5种基本数据类型：Undifined、Null、Boolean、Number和String。

基本类型值和引用类型值具有以下特点：

- （1）基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
- （2）从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本。
- （3）引用类型的值是对象，保存在堆内存中。
- （4）包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。
- （5）从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；
- （6）确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。

所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执行环境决定了变量的声明周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：

- （1）执行环境中有全局执行环境（也称为全局环境）和函数执行环境之分。
- （2）每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链。
- （3）函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境。
- （4）全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中定义的任何数据。
- （5）变量的执行环境有助于确定应该何时释放内存。

JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。

解除变量的引用不仅有助于消除循环引用想象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。

## 第五章引用类型

引用类型的值（对象）是引用类型的一个实例。在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常常被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。

对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。

### 5.1 Object类型

在通过对象字面量定义对象时，实际上不会调用Object构造函数。

一般来讲，命名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。

### 5.2 Array类型

ECMAScript数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据。而且，ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。

### 5.3 Date类型

ECMAScript的Date类型是在早期Java中的java.util.Date类基础上构建的。

### 5.4 RegExp类型

ECMAScript通过RegExp类型来支持正则表达式。使用下面类似perl的语法，就可以创建一个正则表达式。
```Javascript
   var expression=/pattern/flags;
```
其中的模式（pattern）部分可以是任意简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可以带有一个或多个标志（flags），用以标明正则表达式的行为。

正则表达式的匹配模式支持下列3个标志：

- （1）g：表示全局（global）模式，即模式将被应用与所有字符串，而非发现第一个匹配项时立即停止。
- （2）i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写。
- （3）m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。
- （4）u：表示Unicode模式，用来正确处理大于\uFFFF的Unicode字符。ES6新增。
- （5）y：叫做“粘连”（sticky）修饰符。ES6新增。

### 5.5 Function类型

每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。

#### 5.5.1 没有重载（深入理解）

将函数名想象为指针，也有助于理解为什么ECMAScript中没有函数重载的概念。
简单讲就是函数名也与其他引用对象一样只是引用地址，当多个名称相同的函数同时声明时，最后一个会覆盖之前所有。

#### 5.5.2 函数声明与函数表达式

实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。

#### 5.5.3 作为值的函数

因为ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以想传递参数一样把一个函数传递给另一个函数，而且可以进一个函数作为另一个函数的结果返回。

#### 5.5.4 函数内部属性

在函数内部，有两个特殊的对象：arguments和this。其中，arguments是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。

函数内部的另一个特殊对象是this，其行为与Java和C#中的this大致类似。换句话说，this引用的是函数据以执行的环境对象——或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）。

#### 5.5.5 函数属性和方法

ECMAScript中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length和prototype，其中，length属性表示函数希望接收到函命名参数的个数。（在ES6中使用了rest参数，函数的length就等于0）

对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的。在ECMAScript5中，prototype属性是不可枚举的，因此使用for-in无法发现。

每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域调用函数，实际上等于设置函数体内this对象的值。首先apply()方法接受两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以使Array的实例，也可以是arguments对象。

call()方法与apply()方法的作用相同，它们的区别仅在于接受参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，编号的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来。

事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。

每个函数继承的toLocalStirng()和toString()方法始终都返回函数的代码。另一个继承的valueOf()方法同样也只返回函数代码。

### 5.6 基本包装类型

实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。

引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在与一行代码执行的瞬间，然后立即被销毁。这也意味着我们不能在运行时为基本类型值添加属性和方法。

Object构造函数也会像工程方法一样，根据传入值的类型返回相应基本包装类型的实例。

### 5.7 单体内置对象

ECMA-262对内置对象的定义是：“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就存在了。”

#### 5.7.1 Global对象

ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象”来定义的，换句话说，不属于任何其他对象的属性和函数，都是Global对象的属性。

URI方法encodeURI()、encodeURIComponent()、decodeURI()和decodeURIComponent()用于替代已经被ECMA262第3版废弃的escape()和unescape()方法。URI方法能够编码所有Unicode字符，而原来的方法只能正确地编码ASCII字符。因此在开发实践中，特别是在产品级的代码中，一定要使用URI方法，不要使用escape()和unescape()方法。

在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建。

严格模式下，在外部访问不到eval()中创建的任何变量或函数。

#### 5.7.2 Math常用对象

* （1）Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数。
* （2）Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数。
* （3）Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数。
* （4）Math.random()方法返回介于0和1之间一个随机数，不包括0和1。

[继续下一篇](javascript_02.md)